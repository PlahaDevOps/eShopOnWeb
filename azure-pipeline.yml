trigger:
  branches:
    include:
      - main

pool:
  name: Default  # Uses your self-hosted agent on VM2

variables:
  solution: 'eShopOnWeb.sln'
  buildConfiguration: 'Release'
  publishDir: '$(Build.ArtifactStagingDirectory)/publish'
  iisTargetPath: 'C:\inetpub\eShopOnWeb'  # <-- your actual running folder

steps:

# Restore dependencies
- script: |
    dotnet restore $(solution)
  displayName: 'Restore NuGet Packages'

# Build the web project
- script: |
    dotnet build src/Web/Web.csproj -c $(buildConfiguration)
  displayName: 'Build Web Project'

# Optional tests
- script: |
    dotnet test tests/UnitTests/UnitTests.csproj --configuration $(buildConfiguration)
  displayName: 'Run Unit Tests'
  continueOnError: true

# Publish to staging folder
- script: |
    dotnet publish src/Web/Web.csproj -c $(buildConfiguration) -o $(publishDir)
  displayName: 'Publish Web Project'

# Clean IIS target folder
- task: PowerShell@2
  displayName: 'Clean IIS Folder'
  inputs:
    targetType: inline
    script: |
      Write-Host "Cleaning IIS folder: $(iisTargetPath)"
      
      # Stop the app pool first to release file locks
      try {
        Import-Module WebAdministration -ErrorAction SilentlyContinue
        $appPool = "eShopOnWeb"
        if (Test-Path "IIS:\AppPools\$appPool") {
          Write-Host "Stopping app pool '$appPool' to release file locks..."
          Stop-WebAppPool -Name $appPool -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 5
        }
      }
      catch {
        Write-Host "Could not stop app pool (this is normal if WebAdministration is not available)"
      }
      
      # Also try to stop the website if it exists
      try {
        $siteName = "eShopOnWeb"
        if (Test-Path "IIS:\Sites\$siteName") {
          Write-Host "Stopping website '$siteName'..."
          Stop-Website -Name $siteName -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 3
        }
      }
      catch {
        Write-Host "Could not stop website (this is normal if WebAdministration is not available)"
      }
      
      # Clean the directory with retry logic
      if (Test-Path "$(iisTargetPath)") {
        Write-Host "Attempting to clean directory..."
        
        # Try multiple times with different approaches
        $maxRetries = 3
        for ($i = 1; $i -le $maxRetries; $i++) {
          try {
            Write-Host "Clean attempt $i of $maxRetries..."
            
            # First try: Remove files individually
            Get-ChildItem -Path "$(iisTargetPath)" -Recurse -File | ForEach-Object {
              try {
                Remove-Item $_.FullName -Force -ErrorAction SilentlyContinue
              }
              catch {
                Write-Host "Could not remove file: $($_.Name)"
              }
            }
            
            # Second try: Remove empty directories
            Get-ChildItem -Path "$(iisTargetPath)" -Recurse -Directory | Sort-Object FullName -Descending | ForEach-Object {
              try {
                Remove-Item $_.FullName -Force -ErrorAction SilentlyContinue
              }
              catch {
                Write-Host "Could not remove directory: $($_.Name)"
              }
            }
            
            Write-Host "Clean attempt $i completed"
            break
          }
          catch {
            Write-Host "Clean attempt $i failed: $($_.Exception.Message)"
            if ($i -lt $maxRetries) {
              Start-Sleep -Seconds 2
            }
          }
        }
        
        Write-Host "Directory cleaning completed"
      } else {
        New-Item -ItemType Directory -Path "$(iisTargetPath)" -Force
        Write-Host "Created IIS folder"
      }

# Copy published files to IIS folder
- task: CopyFiles@2
  displayName: 'Deploy to IIS'
  inputs:
    SourceFolder: '$(publishDir)'
    Contents: '**'
    TargetFolder: '$(iisTargetPath)'
    OverWrite: true
    CleanTargetFolder: false

# Recycle app pool and start website
- task: PowerShell@2
  displayName: 'Recycle IIS App Pool and Start Website'
  inputs:
    targetType: inline
    script: |
      $appPool = "eShopOnWeb"
      $siteName = "eShopOnWeb"
      Write-Host "Starting IIS services..."
      
      try {
        Import-Module WebAdministration -ErrorAction Stop
        
        # Start the app pool if it was stopped during cleaning
        if (Test-Path "IIS:\AppPools\$appPool") {
          Write-Host "Starting app pool '$appPool'..."
          Start-WebAppPool -Name $appPool -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 3
          
          # Now recycle it
          Write-Host "Recycling app pool '$appPool'..."
          Restart-WebAppPool -Name $appPool
          Write-Host "App pool '$appPool' recycled successfully."
        } else {
          Write-Host "App pool '$appPool' not found. Available app pools:"
          Get-ChildItem IIS:\AppPools | ForEach-Object { Write-Host "  - $($_.Name)" }
        }
        
        # Start the website if it was stopped
        if (Test-Path "IIS:\Sites\$siteName") {
          Write-Host "Starting website '$siteName'..."
          Start-Website -Name $siteName -ErrorAction SilentlyContinue
          Write-Host "Website '$siteName' started successfully."
        } else {
          Write-Host "Website '$siteName' not found. Available sites:"
          Get-ChildItem IIS:\Sites | ForEach-Object { Write-Host "  - $($_.Name)" }
        }
      }
      catch {
        Write-Host "Warning: Could not manage IIS services: $($_.Exception.Message)"
        Write-Host "This might be normal if WebAdministration module is not available"
      }

# Optional verification
- task: PowerShell@2
  displayName: 'Verify Site is Running'
  inputs:
    targetType: inline
    script: |
      $url = "http://localhost:8080"
      Write-Host "Verifying site at: $url"
      
      # Wait a moment for IIS to process the deployment
      Start-Sleep -Seconds 5
      
      try {
        $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 15
        if ($response.StatusCode -eq 200) {
          Write-Host "✅ Site is running correctly at $url"
        } else {
          Write-Host "⚠️ Site responded with status: $($response.StatusCode)"
        }
      }
      catch {
        Write-Host "❌ Could not verify site: $($_.Exception.Message)"
        Write-Host "This might be normal if the site needs more time to start"
        Write-Host "You can manually check the application at $url"
      }